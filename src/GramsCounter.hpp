/// \file 
/// \author Franck Dary
/// \author Cindy Aloui
#ifndef GRAMSCOUNTER__H
#define GRAMSCOUNTER__H

#include <unordered_map>
#include <vector>
#include "File.hpp"

class Lexicon;
class Gram;
class GramsCounter;

namespace std {struct hash<Gram>;}

/////////////////////////////////////////////////////////////////////////////
/// \brief Represents a monogram, a bigram or a trigram.
///
////////////////////////////////////////////////////////////////////////////
class Gram
{
	private :

	std::vector<unsigned int> tokens;

	/////////////////////////////////////////////////////////////////////////////
	/// \brief Construct the monogram t1.
	///
	/// \param t1 Token.
	///
	////////////////////////////////////////////////////////////////////////////
	Gram(unsigned int t1);

	/////////////////////////////////////////////////////////////////////////////
	/// \brief Construct the bigram (t1,t2).
	///
	/// \param t1 Token.
	/// \param t2 Token.
	///
	////////////////////////////////////////////////////////////////////////////
	Gram(unsigned int t1, unsigned int t2);

	/////////////////////////////////////////////////////////////////////////////
	/// \brief Construct the trigram (t1,t2,t3)
	///
	/// \param t1 Token.
	/// \param t2 Token.
	/// \param t3 Token.
	///
	////////////////////////////////////////////////////////////////////////////
	Gram(unsigned int t1, unsigned int t2, unsigned int t3);

	public :

	/////////////////////////////////////////////////////////////////////////////
	/// \brief Compares equality.
	///
	/// \param other
	///
	/// \return true if other == self.
	///
	////////////////////////////////////////////////////////////////////////////
	bool operator==(const Gram & other) const;
	
	friend class std::hash<Gram>;
	friend class GramsCounter;
};

namespace std
{
	/////////////////////////////////////////////////////////////////////////////
	/// \brief Functor for hashing Gram
	///
	////////////////////////////////////////////////////////////////////////////
	template <>
	struct hash<Gram>
	{
		/////////////////////////////////////////////////////////////////////////////
		/// \brief Hash a Gram.
		///
		/// \param g Gram to be hashed.
		///
		/// \return Hash.
		///
		////////////////////////////////////////////////////////////////////////////
		size_t operator()(const Gram & g) const
		{
    		static hash<unsigned int> hasher;

			size_t seed = 0;

			// From Boost
			for (auto it : g.tokens)
	    		seed ^= hasher(it) + 0x9e3779b9 + (seed<<6) + (seed>>2);

			return seed;
		}
	};
}

/////////////////////////////////////////////////////////////////////////////
/// \brief Represents a language model.
///
/// Once correctly initialized it is able to give the probability of a given
/// Gram.
///
////////////////////////////////////////////////////////////////////////////
class GramsCounter
{
	private :

	std::unordered_map<Gram, unsigned int> nbOcc;

	unsigned int nbMonograms;
	unsigned int nbBigrams;
	unsigned int nbTrigrams;

	float alpha = 0.1;
	unsigned int nbTokensTotal;

	public :

	/////////////////////////////////////////////////////////////////////////////
	/// \brief Constructor.
	///
	////////////////////////////////////////////////////////////////////////////
	GramsCounter();

	/////////////////////////////////////////////////////////////////////////////
	/// \brief Count one occurence of the monogram t1.
	///
	/// \param t1 Token.
	///
	////////////////////////////////////////////////////////////////////////////
	void addGram(unsigned int t1);

	/////////////////////////////////////////////////////////////////////////////
	/// \brief Count one occurence of the bigram (t1,t2).
	///
	/// \param t1 Token.
	/// \param t2 Token.
	///
	////////////////////////////////////////////////////////////////////////////
	void addGram(unsigned int t1, unsigned int t2);

	/////////////////////////////////////////////////////////////////////////////
	/// \brief Count one occurence of the trigram (t1,t2,t3).
	///
	/// \param t1 Token.
	/// \param t2 Token.
	/// \param t3 Token.
	///
	////////////////////////////////////////////////////////////////////////////
	void addGram(unsigned int t1, unsigned int t2, unsigned int t3);

	/////////////////////////////////////////////////////////////////////////////
	/// \brief Get probability of Gram.
	///
	/// \param t1 Token.
	///
	/// \return Probability of monogram t1.
	///
	////////////////////////////////////////////////////////////////////////////
	float getProb(unsigned int t1) const;

	/////////////////////////////////////////////////////////////////////////////
	/// \brief Get probability of Gram.
	///
	/// \param t1 Token.
	/// \param t2 Token.
	///
	/// \return Probability of bigram (t1,t2).
	///
	////////////////////////////////////////////////////////////////////////////
	float getProb(unsigned int t1, unsigned int t2) const;

	/////////////////////////////////////////////////////////////////////////////
	/// \brief Get probability of Gram.
	///
	/// \param t1 Token.
	/// \param t2 Token.
	/// \param t3 Token.
	///
	/// \return Probability of trigram (t1,t2,t3).
	///
	////////////////////////////////////////////////////////////////////////////
	float getProb(unsigned int t1, unsigned int t2, unsigned int t3) const;

	/////////////////////////////////////////////////////////////////////////////
	/// \brief Opposite of logarithm of getProb().
	///
	/// \param t1 Token.
	///
	/// \return -log(getProb()).
	///
	////////////////////////////////////////////////////////////////////////////
	float getLogProb(unsigned int t1) const;

	/////////////////////////////////////////////////////////////////////////////
	/// \brief Opposite of logarithm of getProb().
	///
	/// \param t1 Token.
	/// \param t2 Token.
	///
	/// \return -log(getProb()).
	///
	////////////////////////////////////////////////////////////////////////////
	float getLogProb(unsigned int t1, unsigned int t2) const;

	/////////////////////////////////////////////////////////////////////////////
	/// \brief Opposite of logarithm of getProb().
	///
	/// \param t1 Token.
	/// \param t2 Token.
	/// \param t3 Token.
	///
	/// \return -log(getProb()).
	///
	////////////////////////////////////////////////////////////////////////////
	float getLogProb(unsigned int t1, unsigned int t2, unsigned int t3) const;

	/////////////////////////////////////////////////////////////////////////////
	/// \brief Read the language model from a file.
	///
	/// \param input Path to file containing language model, as created by print()
	/// \see print
	///
	////////////////////////////////////////////////////////////////////////////
	void read(File & input);

	/////////////////////////////////////////////////////////////////////////////
	/// \brief Save the language model into a file.
	///
	/// \param output File descriptor the language model will be saved into.
	/// \see read
	///
	////////////////////////////////////////////////////////////////////////////
	void print(FILE * output);

	/////////////////////////////////////////////////////////////////////////////
	/// \brief Print the language model into a file, human readable format.
	///
	/// \param output File descriptor the language model will be savec into.
	/// \param lexicon Lexicon containing every token of the language model.
	///
	////////////////////////////////////////////////////////////////////////////
	void print(FILE * output, Lexicon & lexicon);
};

#endif
